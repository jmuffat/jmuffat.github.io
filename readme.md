# genAI in the bottle

![aladdin and the wonderful lamp](aladdin-lamp.jpg)

To me, generative AI, as it is presented today is very much like the genie in
the bottle. You rub the bottle, genie comes out, grants you three wishes. So, 
here you go, you use your first wish to get another bottle you can rub and have
a genie grant you three wishes. Then you go on and use your second wish but, of
course, the genie's interpretation is a bit off and unwanted side effects happen. 
But that's ok, you can use your third wish to make it all go away and start over 
with the extra bottle. Story repeats, you obtain an extra bottle, make an improved
second wish and use your third to revert whatever went wrong. What started like 
a simple "make a wish" process turns out in the end to look very much like any
endeavour, where converging towards a goal is _work_. 

So, is this really worth the effort ? 

The first thing I realised is that code generated by AI is disposable. Even if
it was readable, verifiable and maintainable, it would still be disposable, simply
because it is so cheap to produce. And, really, at this stage at least, it is neither
readable nor verifiable, which makes the prospect of maintaining this code quite
daunting.

I spent a lot of time comparing genAI code to disposable tableware, thinking 
there were just two categories: "real" things and "disposable" things. But 
I don't like thinking in binary ways, so I started thinking "maybe, genAI is like
plastic": worse in many ways, but so cheap it's still a win.

That's when I ended up realising genAI might actually be used in a readable, 
verifiable and maintainable manner. This can be accomplished easily by having
us, developpers, work at a higher level. It feels like it should be possible for us
to define modules and their relationship, and use genAI to build those smaller
modules. This brings granularity, we can regenerate a module when it doesn't give
satisfaction, we can lock a module down once it does. We can insert modules at
interfaces to debug|QA|benchmark. We can have important modules coded the old fashion
way. We can build a methodology that proves we're converging towards a goal.

This project aims to formalise this modular approach, to design ways to
compartmentalise robustly while limiting friction and, ideally, to provide
tooling that implements the vision.

